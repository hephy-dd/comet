{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COMET Control and Measurement Toolkit Providing generic instrument drivers, instrument emulators for testing and and utilities for instrumentation applications. Inspired by QCoDeS , Lantz , Slave , FluidLab . Install Install from GitHub using pip pip install https://github.com/hephy-dd/comet/archive/refs/tags/v1.5.0.tar.gz","title":"Home"},{"location":"#comet","text":"Control and Measurement Toolkit Providing generic instrument drivers, instrument emulators for testing and and utilities for instrumentation applications. Inspired by QCoDeS , Lantz , Slave , FluidLab .","title":"COMET"},{"location":"#install","text":"Install from GitHub using pip pip install https://github.com/hephy-dd/comet/archive/refs/tags/v1.5.0.tar.gz","title":"Install"},{"location":"drivers/","text":"Drivers Generic instrument drivers use a PyVISA compatible resource to communicate with. See package comet.driver for available instrument drivers. Examples import pyvisa from comet.driver.keithley import K2470 rm = pyvisa.ResourceManager(\"@py\") with rm.open_resource(\"TCPIP::0.0.0.0::11001::SOCKET\") as res: smu = K2470(res) print(smu.identify()) smu.reset() smu.function = smu.FUNCTION_VOLTAGE smu.current_compliance = 1e-6 smu.output = smu.OUTPUT_ON smu.voltage_level = 5.0 reading = smu.measure_current() print(reading) smu.voltage_level = 0.0 smu.output = smu.OUTPUT_OFF Loading driver by module name using driver factory. from comet.driver import driver_factory rm = pyvisa.ResourceManager(\"@py\") with rm.open_resource(\"TCPIP::0.0.0.0::11001::SOCKET\") as res: smu = driver_factory(\"urn:comet:model:keithley:2410\")(res) Switching between generic drivers. from comet.driver import driver_factory smu_drivers = { \"Keithley2410\": driver_factory(\"urn:comet:model:keithley:2410\"), \"Keithley2470\": driver_factory(\"urn:comet:model:keithley:2470\"), \"Keithley2657A\": driver_factory(\"urn:comet:model:keithley:2657a\"), } driver_name = \"Keithley2470\" rm = pyvisa.ResourceManager(\"@py\") with rm.open_resource(\"TCPIP::0.0.0.0::11001::SOCKET\") as res: smu = smu_drivers.get(driver_name)(res) Open multiple resources using contextlib.ExitStack to guarantee all resources are automatically closed properly. from contextlib import ExitStack import pyvisa resource_name_1 = \"TCPIP::0.0.0.0::11001::SOCKET\" resource_name_2 = \"TCPIP::0.0.0.0::11002::SOCKET\" rm = pyvisa.ResourceManager(\"@py\") with ExitStack() as stack: res_1 = stack.enter_context(rm.open_resource(resource_name_1)) res_2 = stack.enter_context(rm.open_resource(resource_name_2)) ... See also Station for handling multiple instrument connections.","title":"Drivers"},{"location":"drivers/#drivers","text":"Generic instrument drivers use a PyVISA compatible resource to communicate with. See package comet.driver for available instrument drivers.","title":"Drivers"},{"location":"drivers/#examples","text":"import pyvisa from comet.driver.keithley import K2470 rm = pyvisa.ResourceManager(\"@py\") with rm.open_resource(\"TCPIP::0.0.0.0::11001::SOCKET\") as res: smu = K2470(res) print(smu.identify()) smu.reset() smu.function = smu.FUNCTION_VOLTAGE smu.current_compliance = 1e-6 smu.output = smu.OUTPUT_ON smu.voltage_level = 5.0 reading = smu.measure_current() print(reading) smu.voltage_level = 0.0 smu.output = smu.OUTPUT_OFF Loading driver by module name using driver factory. from comet.driver import driver_factory rm = pyvisa.ResourceManager(\"@py\") with rm.open_resource(\"TCPIP::0.0.0.0::11001::SOCKET\") as res: smu = driver_factory(\"urn:comet:model:keithley:2410\")(res) Switching between generic drivers. from comet.driver import driver_factory smu_drivers = { \"Keithley2410\": driver_factory(\"urn:comet:model:keithley:2410\"), \"Keithley2470\": driver_factory(\"urn:comet:model:keithley:2470\"), \"Keithley2657A\": driver_factory(\"urn:comet:model:keithley:2657a\"), } driver_name = \"Keithley2470\" rm = pyvisa.ResourceManager(\"@py\") with rm.open_resource(\"TCPIP::0.0.0.0::11001::SOCKET\") as res: smu = smu_drivers.get(driver_name)(res) Open multiple resources using contextlib.ExitStack to guarantee all resources are automatically closed properly. from contextlib import ExitStack import pyvisa resource_name_1 = \"TCPIP::0.0.0.0::11001::SOCKET\" resource_name_2 = \"TCPIP::0.0.0.0::11002::SOCKET\" rm = pyvisa.ResourceManager(\"@py\") with ExitStack() as stack: res_1 = stack.enter_context(rm.open_resource(resource_name_1)) res_2 = stack.enter_context(rm.open_resource(resource_name_2)) ... See also Station for handling multiple instrument connections.","title":"Examples"},{"location":"emulators/","text":"Emulators See package comet.emulator for available instrument emulators. Using TCP sockets To emulate one or more instruments using TCP sockets create a emulators.yaml configuration file in your project directory specifying instrument model URN and port . emulators: smu: model: urn:comet:model:keithley:2470 port: 11001 lcr: model: urn:comet:model:keysight:e4980a port: 11002 # Set message termination (\\n, \\r, \\n, \\r\\n, CR, LF, CRLF) termination: '\\n' # Set specific options options: cp.min: 2.5e-10 cp.max: 2.5e-9 To spin up the emulator sockets run comet-emulator or alternatively python -m comet.emulator . comet-emulator Use command line argument -f (or --file ) to use a custom configuration file. comet-emulator -f custom_emulators.yaml The Emulators file The default path for an Emulators file is emulators.yaml (preferred) or emulators.yml that is placed in the current working directory. If both files exist, comet-emulator prefers the canonical emulators.yaml . Using Resources To use instrument emulators as resources use function open_emulator from package comet.emulator to open a mock resource for an instrument. from comet.emulator import open_emulator with open_emulator(\"urn:comet:model:keithley:2410\") as res: print(res.query(\"*IDN?\")) Mock resources can be used like regular PyVISA resources in combination with instrument drivers. from comet.driver import driver_factory from comet.emulator import open_emulator model_urn = \"urn:comet:model:keithley:2410\" with open_emulator(model_urn) as res: instr = driver_factory(model_urn)(res) print(instr.identify()) To set emulator specific options either provide an options dict to open_emulator or update the emulator.options dict directly. from comet.emulator import open_emulator options = {\"correction_open_delay\": 2.0} with open_emulator(\"urn:comet:model:keysight:e4980a\", options=options) as res: res.emulator.options.update({ \"cp.min\": 2.5e-10, \"cp.max\": 2.5e-9, })","title":"Emulators"},{"location":"emulators/#emulators","text":"See package comet.emulator for available instrument emulators.","title":"Emulators"},{"location":"emulators/#using-tcp-sockets","text":"To emulate one or more instruments using TCP sockets create a emulators.yaml configuration file in your project directory specifying instrument model URN and port . emulators: smu: model: urn:comet:model:keithley:2470 port: 11001 lcr: model: urn:comet:model:keysight:e4980a port: 11002 # Set message termination (\\n, \\r, \\n, \\r\\n, CR, LF, CRLF) termination: '\\n' # Set specific options options: cp.min: 2.5e-10 cp.max: 2.5e-9 To spin up the emulator sockets run comet-emulator or alternatively python -m comet.emulator . comet-emulator Use command line argument -f (or --file ) to use a custom configuration file. comet-emulator -f custom_emulators.yaml","title":"Using TCP sockets"},{"location":"emulators/#the-emulators-file","text":"The default path for an Emulators file is emulators.yaml (preferred) or emulators.yml that is placed in the current working directory. If both files exist, comet-emulator prefers the canonical emulators.yaml .","title":"The Emulators file"},{"location":"emulators/#using-resources","text":"To use instrument emulators as resources use function open_emulator from package comet.emulator to open a mock resource for an instrument. from comet.emulator import open_emulator with open_emulator(\"urn:comet:model:keithley:2410\") as res: print(res.query(\"*IDN?\")) Mock resources can be used like regular PyVISA resources in combination with instrument drivers. from comet.driver import driver_factory from comet.emulator import open_emulator model_urn = \"urn:comet:model:keithley:2410\" with open_emulator(model_urn) as res: instr = driver_factory(model_urn)(res) print(instr.identify()) To set emulator specific options either provide an options dict to open_emulator or update the emulator.options dict directly. from comet.emulator import open_emulator options = {\"correction_open_delay\": 2.0} with open_emulator(\"urn:comet:model:keysight:e4980a\", options=options) as res: res.emulator.options.update({ \"cp.min\": 2.5e-10, \"cp.max\": 2.5e-9, })","title":"Using Resources"},{"location":"helpers/","text":"Helpers Estimate Estimate remaining time for loop operations using class Estimate . Call method advance to proceed to the next iteration and update average and remaining time calculation. from comet.estimate import Estimate n = 42 e = Estimate(n) # start stopwatch for i in range(n): ... e.advance() # stop time since last step print(\"passed:\", e.passed) print(\"remaining time:\", e.remaining) print(\"elapsed time:\", e.elapsed) print(\"average time:\", e.average) Filters Test if standard deviation / mean < threshold using function std_mean_filter . from comet.filters import std_mean_filter if std_mean_filter(readings, threshold=0.005): ... Functions Voltage ramps using LinearRange generator class. from comet.functions import LinearRange for voltage in LinearRange(-10, +10, 0.25): ... Parameter Bind typed and bounded parameters to classes inheriting from class ParameterBase . from comet.parameter import ParameterBase, Parameter class Measurement(ParameterBase): voltage_level = Parameter(unit=\"V\", minimum=-1000, maximum=1000) current_compliance = Parameter(default=\"25 uA\", unit=\"A\", minimum=0, maximum=\"10 mA\") terminal = Parameter(default=\"front\", choice=[\"front\", \"rear\"]) write_output = Parameter(default=True, type=bool) measurement = Measurement({\"voltage_level\": \"100 V\"}) # supply required parameters # Get dictionary of all parameter values. print(measurement.parameters) # {'voltage_level': 100.0, 'current_compliance': 2.5e-05, 'terminal': 'front', 'write_output': True} # Update parameter values measurement.update_parameters({\"current_compliance\": \"50 uA\", \"terminal\": \"rear\"}) # Access individual parameter print(measurement.voltage_level) # 100.0 print(measurement.current_compliance) # 5e-05 print(measurement.terminal) # 'rear' measurement.write_output = False # AttributeError: can't set parameter: 'write_output' Utils Use pint unit registry to convert between units. from comet.utils import ureg, to_unit quantity = ureg(\"25 nA\").to(\"A\") print(to_unit(quantity, \"mA\")) # 2.5e-05 print(to_unit(\"1200 V\", \"kV\")) # 1.2 print(to_unit(2.5, \"pA\")) # 2.5","title":"Helpers"},{"location":"helpers/#helpers","text":"","title":"Helpers"},{"location":"helpers/#estimate","text":"Estimate remaining time for loop operations using class Estimate . Call method advance to proceed to the next iteration and update average and remaining time calculation. from comet.estimate import Estimate n = 42 e = Estimate(n) # start stopwatch for i in range(n): ... e.advance() # stop time since last step print(\"passed:\", e.passed) print(\"remaining time:\", e.remaining) print(\"elapsed time:\", e.elapsed) print(\"average time:\", e.average)","title":"Estimate"},{"location":"helpers/#filters","text":"Test if standard deviation / mean < threshold using function std_mean_filter . from comet.filters import std_mean_filter if std_mean_filter(readings, threshold=0.005): ...","title":"Filters"},{"location":"helpers/#functions","text":"Voltage ramps using LinearRange generator class. from comet.functions import LinearRange for voltage in LinearRange(-10, +10, 0.25): ...","title":"Functions"},{"location":"helpers/#parameter","text":"Bind typed and bounded parameters to classes inheriting from class ParameterBase . from comet.parameter import ParameterBase, Parameter class Measurement(ParameterBase): voltage_level = Parameter(unit=\"V\", minimum=-1000, maximum=1000) current_compliance = Parameter(default=\"25 uA\", unit=\"A\", minimum=0, maximum=\"10 mA\") terminal = Parameter(default=\"front\", choice=[\"front\", \"rear\"]) write_output = Parameter(default=True, type=bool) measurement = Measurement({\"voltage_level\": \"100 V\"}) # supply required parameters # Get dictionary of all parameter values. print(measurement.parameters) # {'voltage_level': 100.0, 'current_compliance': 2.5e-05, 'terminal': 'front', 'write_output': True} # Update parameter values measurement.update_parameters({\"current_compliance\": \"50 uA\", \"terminal\": \"rear\"}) # Access individual parameter print(measurement.voltage_level) # 100.0 print(measurement.current_compliance) # 5e-05 print(measurement.terminal) # 'rear' measurement.write_output = False # AttributeError: can't set parameter: 'write_output'","title":"Parameter"},{"location":"helpers/#utils","text":"Use pint unit registry to convert between units. from comet.utils import ureg, to_unit quantity = ureg(\"25 nA\").to(\"A\") print(to_unit(quantity, \"mA\")) # 2.5e-05 print(to_unit(\"1200 V\", \"kV\")) # 1.2 print(to_unit(2.5, \"pA\")) # 2.5","title":"Utils"},{"location":"station/","text":"Station A Station represents a physical arrangement of instruments that you can control and interact with programmatically. It serves as a centralized interface for managing multiple instruments in a safe way. Creation From API Add instruments programmatically using API methods. This is useful when you want full control in code without relying on external config files. from comet.station import Station station = Station() station.add_instrument(\"smu\", resource_name=\"GPIB::16\", model=\"urn:comet:model:keithley:2410\") station.add_instrument(\"dmm\", resource_name=\"GPIB::18\", model=\"urn:comet:model:keithley:2700\") From dict Create a station from a config dict: from comet.station import Station station = Station.from_config({\"instruments\": { \"smu\": {\"resource_name\": \"GPIB::16\", \"model\": \"urn:comet:model:keithley:2410\"}, \"dmm\": {\"resource_name\": \"GPIB::18\", \"model\": \"urn:comet:model:keithley:2700\"}, }}) From config file Create a station from a config file (either YAML or JSON): # station.yml instruments: smu: resource_name: GPIB::16 model: urn:comet:model:keithley:2410 dmm: resource_name: GPIB::18 model: urn:comet:model:keithley:2700 from comet.station import Station station = Station.from_file(\"station.yml\") If filename is omitted a station tries to load station.yaml , station.yml or station.json relative to current working directory (in given order). station = Station.from_file() # loads station.y[a]ml|json Or pass a file like object to read from: with open(\"station.yml\") as fp: station = Station.from_file(fp) Usage A Station is used as a context manager. When entering the with block, it automatically opens connections to all configured instruments. When the block ends\u2014whether normally or due to an error\u2014it safely closes all connections. Within the block, instruments can be accessed as attributes or dictionary-style keys, and the station itself is iterable for convenient bulk operations. from comet.station import Station # Load station configuration (YAML, JSON, or dict) with Station.from_file() as station: # Access instruments by attribute print(station.smu.identify()) print(station.dmm.identify()) # Or by dictionary-style key access (Station implements Mapping) print(station[\"smu\"].identify()) print(station[\"dmm\"].identify()) # Iterate over all instruments for name, instrument in station.items(): print(f\"{name}: {instrument.identify()}\")","title":"Station"},{"location":"station/#station","text":"A Station represents a physical arrangement of instruments that you can control and interact with programmatically. It serves as a centralized interface for managing multiple instruments in a safe way.","title":"Station"},{"location":"station/#creation","text":"","title":"Creation"},{"location":"station/#from-api","text":"Add instruments programmatically using API methods. This is useful when you want full control in code without relying on external config files. from comet.station import Station station = Station() station.add_instrument(\"smu\", resource_name=\"GPIB::16\", model=\"urn:comet:model:keithley:2410\") station.add_instrument(\"dmm\", resource_name=\"GPIB::18\", model=\"urn:comet:model:keithley:2700\")","title":"From API"},{"location":"station/#from-dict","text":"Create a station from a config dict: from comet.station import Station station = Station.from_config({\"instruments\": { \"smu\": {\"resource_name\": \"GPIB::16\", \"model\": \"urn:comet:model:keithley:2410\"}, \"dmm\": {\"resource_name\": \"GPIB::18\", \"model\": \"urn:comet:model:keithley:2700\"}, }})","title":"From dict"},{"location":"station/#from-config-file","text":"Create a station from a config file (either YAML or JSON): # station.yml instruments: smu: resource_name: GPIB::16 model: urn:comet:model:keithley:2410 dmm: resource_name: GPIB::18 model: urn:comet:model:keithley:2700 from comet.station import Station station = Station.from_file(\"station.yml\") If filename is omitted a station tries to load station.yaml , station.yml or station.json relative to current working directory (in given order). station = Station.from_file() # loads station.y[a]ml|json Or pass a file like object to read from: with open(\"station.yml\") as fp: station = Station.from_file(fp)","title":"From config file"},{"location":"station/#usage","text":"A Station is used as a context manager. When entering the with block, it automatically opens connections to all configured instruments. When the block ends\u2014whether normally or due to an error\u2014it safely closes all connections. Within the block, instruments can be accessed as attributes or dictionary-style keys, and the station itself is iterable for convenient bulk operations. from comet.station import Station # Load station configuration (YAML, JSON, or dict) with Station.from_file() as station: # Access instruments by attribute print(station.smu.identify()) print(station.dmm.identify()) # Or by dictionary-style key access (Station implements Mapping) print(station[\"smu\"].identify()) print(station[\"dmm\"].identify()) # Iterate over all instruments for name, instrument in station.items(): print(f\"{name}: {instrument.identify()}\")","title":"Usage"}]}